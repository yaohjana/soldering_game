<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>焊接大師 V3 - 職人雙手協作篇</title>
    <style>
        /* --- 基礎日系 Pop 風格設定 --- */
        :root {
            --pop-pink: #FF0055;
            --pop-yellow: #FFE600;
            --pop-cyan: #00FFFF;
            --pop-black: #222222;
            --pop-white: #FFFFFF;
            --bg-pattern: radial-gradient(#222 15%, transparent 16%) 0 0;
        }

        body {
            margin: 0;
            background-color: var(--pop-yellow);
            background-image: var(--bg-pattern);
            background-size: 20px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: "Microsoft JhengHei", sans-serif;
            overflow: hidden; /* 防止滾動 */
        }

        /* 雜誌標題 */
        .header-badge {
            background: var(--pop-cyan); color: var(--pop-black);
            padding: 10px 20px; font-weight: 900; border: 3px solid var(--pop-black);
            transform: rotate(-5deg) skewX(-10deg);
            box-shadow: 5px 5px 0px var(--pop-black);
            margin-top: 20px; z-index: 10;
        }
        h1 { margin: 0; font-size: 1.8rem; }

        /* --- 遊戲主區域 --- */
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            background: #333;
            border: 5px solid var(--pop-black);
            box-shadow: 10px 10px 0px var(--pop-black);
            margin: 20px;
            overflow: hidden;
            cursor: none; /* 隱藏滑鼠游標，用烙鐵代替 */
            background-image: 
                linear-gradient(rgba(0,100,50,0.8), rgba(0,100,50,0.8)), /* PCB綠 */
                linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1) 75%, transparent 75%);
            background-size: 100% 100%, 20px 20px;
        }

        /* 焊盤 (目標區域) */
        #pad {
            position: absolute;
            width: 80px; height: 80px;
            background: #C0C0C0;
            border: 3px solid #888;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            transition: background-color 0.2s;
        }
        /* 加熱時變紅 */
        #pad.heating { background: #ff7b7b; box-shadow: 0 0 20px #ff3300; border-color: #ff3300;}

        /* 待焊電線 (固定在焊盤上) */
        #wire-target {
            position: absolute;
            width: 120px; height: 12px;
            background: linear-gradient(to bottom, #444, #222); /* 黑色絕緣皮 */
            top: 50%; left: 50%;
            transform: translate(-100%, -50%); /* 從左側接入 */
            z-index: 2;
            border-radius: 5px 0 0 5px;
        }
        /* 電線露出的銅芯 */
        #wire-target::after {
            content: ''; position: absolute; right: -20px; top: 1px;
            width: 20px; height: 10px; background: #B87333; border-radius: 0 5px 5px 0;
        }

        /* 焊錫融化後的錫點 (動態變大) */
        #solder-blob {
            position: absolute;
            width: 0px; height: 0px;
            background: linear-gradient(135deg, #fff 0%, #aaa 100%);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            opacity: 0.9;
        }

        /* --- 玩家控制的物件 --- */

        /* 1. 焊錫線 (鍵盤控制) */
        #user-solder-wire {
            position: absolute;
            width: 300px; height: 8px;
            background: linear-gradient(to bottom, #dcdcdc, #999);
            z-index: 20;
            /* 初始位置在右下角 */
            top: 400px; left: 600px; 
            border-radius: 4px 0 0 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            /* 設定旋轉中心在右側，讓尖端移動 */
            transform-origin: right center;
            transform: rotate(-20deg);
            pointer-events: none; /* 不阻擋滑鼠事件 */
            transition: all 0.05s ease-out; /* 平滑移動 */
        }
        /* 焊錫尖端指示點 (用於碰撞偵測) */
        #solder-tip-point {
            position: absolute; left: 0; top: 50%;
            width: 4px; height: 4px; background: red;
            transform: translate(-50%, -50%); opacity: 0; /* 隱藏輔助點 */
        }

        /* 2. 烙鐵 (滑鼠控制) */
        #user-iron {
            position: absolute;
            width: 20px; height: 180px;
            background: linear-gradient(to right, #555, #aaa, #555);
            z-index: 30;
            /* 初始位置 */
            top: -200px; left: -200px;
            pointer-events: none; /* 重要：讓滑鼠事件能穿透烙鐵傳到 game-container */
            /* 設定旋轉中心在筆尖 */
            transform-origin: bottom center;
            transform: rotate(30deg);
            /* 增加握把裝飾 */
            border-top: 60px solid var(--pop-pink);
        }
        /* 烙鐵尖端 */
        #user-iron::after {
            content: ''; position: absolute; bottom: -30px; left: 0;
            width: 0; height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 30px solid #B87333; /* 銅色尖端 */
            filter: drop-shadow(0 0 0px transparent);
            transition: filter 0.2s;
        }
        /* 加熱時尖端發光 */
        #user-iron.active::after {
             border-top-color: #ff5500;
             filter: drop-shadow(0 0 15px #ff3300);
        }
        /* 烙鐵尖端接觸點 (用於判定位置) */
        #iron-tip-point {
            position: absolute; bottom: -30px; left: 50%;
            width: 2px; height: 2px; background: blue;
            transform: translate(-50%, -50%); opacity: 0;
        }


        /* --- UI 介面 --- */
        .controls-info {
            display: flex; gap: 20px; margin-top: 10px;
            font-weight: bold; color: var(--pop-black);
        }
        .control-box {
            background: var(--pop-white); border: 3px solid var(--pop-black);
            padding: 10px 15px; box-shadow: 5px 5px 0px var(--pop-black);
        }
        .key {
            background: var(--pop-black); color: var(--pop-yellow);
            padding: 2px 6px; border-radius: 4px; font-family: monospace;
        }
        .mouse-icon {
            display: inline-block; width: 16px; height: 24px;
            border: 2px solid #000; border-radius: 8px; vertical-align: middle;
            position: relative;
        }
        .mouse-icon::before {
            content:''; position:absolute; top:4px; left:50%; width:2px; height:6px;
            background:#000; transform:translateX(-50%);
        }
        .mouse-icon.left-click { background: var(--pop-pink); }

        /* 溫度與狀態條 */
        .status-panel {
            position: absolute; top: 10px; left: 10px;
            background: var(--pop-white); border: 3px solid var(--pop-black);
            padding: 10px; z-index: 50; box-shadow: 3px 3px 0px rgba(0,0,0,0.3);
            font-weight: bold;
        }
        .bar-box { width: 150px; height: 12px; background: #ddd; border: 2px solid #000; margin-top: 5px;}
        #temp-bar { height: 100%; width: 0%; background: var(--pop-pink); transition: width 0.1s;}
        
        /* 結果訊息 */
        #result-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8); color: white;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        #result-overlay h2 { font-size: 3rem; color: var(--pop-yellow); margin: 0; text-shadow: 3px 3px 0 #000;}

    </style>
</head>
<body>

    <div class="header-badge">
        <h1>焊接大師 V3：職人雙手協作篇</h1>
    </div>

    <div class="controls-info">
        <div class="control-box" style="background: var(--pop-cyan);">
            右手 (滑鼠)：控制烙鐵移動
        </div>
        <div class="control-box" style="background: var(--pop-pink); color:white;">
            <span class="mouse-icon left-click"></span> 左鍵長按：接觸加熱
        </div>
        <div class="control-box" style="background: var(--pop-yellow);">
            左手 (鍵盤)：<span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 或方向鍵移動焊錫
        </div>
    </div>

    <div id="game-container">
        <div class="status-panel">
            <div>焊盤溫度: <span id="temp-text">0</span>°C</div>
            <div class="bar-box"><div id="temp-bar"></div></div>
            <div style="margin-top:8px; font-size:0.9rem; color:#666;">提示：溫度 > 180°C 且焊錫接觸時才會融化</div>
        </div>

        <div id="pad"></div>
        <div id="wire-target"></div>
        <div id="solder-blob"></div>

        <div id="user-solder-wire">
            <div id="solder-tip-point"></div> </div>
        <div id="user-iron">
            <div id="iron-tip-point"></div> </div>

        <div id="result-overlay">
             <h2 id="result-title">完美焊接！</h2>
             <p id="result-desc">形狀飽滿，溫度適中！</p>
             <button onclick="resetGame()" style="padding: 10px 20px; font-size: 1.2rem; font-weight:bold; border:3px solid #000; background:var(--pop-cyan); cursor:pointer;">再試一次</button>
        </div>
    </div>

    <script>
        // --- 遊戲參數設定 ---
        const config = {
            solderMoveSpeed: 4,  // 焊錫移動速度
            heatUpRate: 1.5,     // 加熱速度
            coolDownRate: 2,     // 冷卻速度
            meltTempThreshold: 180, // 開始融化溫度
            maxTemp: 350,        // 最高溫
            idealBlobSizeMin: 60, // 理想焊點最小尺寸
            idealBlobSizeMax: 85  // 理想焊點最大尺寸
        };

        // --- 遊戲狀態 ---
        let gameState = {
            isPlaying: true,
            isMouseHeld: false,
            ironPos: { x: 0, y: 0 },
            solderPos: { x: 600, y: 400 }, // 焊錫初始位置 (相對於 game-container)
            temperature: 25, // 室溫
            blobSize: 0,
            keysPressed: {} // 紀錄按下的按鍵
        };

        // --- DOM 元素獲取 ---
        const container = document.getElementById('game-container');
        const iron = document.getElementById('user-iron');
        const ironTip = document.getElementById('iron-tip-point');
        const solderWire = document.getElementById('user-solder-wire');
        const solderTip = document.getElementById('solder-tip-point');
        const pad = document.getElementById('pad');
        const solderBlob = document.getElementById('solder-blob');
        const tempBar = document.getElementById('temp-bar');
        const tempText = document.getElementById('temp-text');
        const resultOverlay = document.getElementById('result-overlay');

        // 取得容器與焊盤的位置資訊 (用於碰撞計算)
        let containerRect = container.getBoundingClientRect();
        let padRect = pad.getBoundingClientRect();
        let padCenter = {
             x: padRect.left + padRect.width / 2 - containerRect.left,
             y: padRect.top + padRect.height / 2 - containerRect.top
        };
        const padRadius = padRect.width / 2;

        // --- 事件監聽 ---

        // 1. 滑鼠移動：更新烙鐵位置
        container.addEventListener('mousemove', (e) => {
            if (!gameState.isPlaying) return;
            // 計算相對於容器的座標
            gameState.ironPos.x = e.clientX - containerRect.left;
            gameState.ironPos.y = e.clientY - containerRect.top;
            updateIronVisual();
        });

        // 2. 滑鼠按鍵：加熱控制
        container.addEventListener('mousedown', (e) => {
            if (e.button === 0) gameState.isMouseHeld = true;
        });
        window.addEventListener('mouseup', () => { // 綁在 window 避免移出框外卡住
            gameState.isMouseHeld = false;
        });

        // 3. 鍵盤控制：焊錫移動
        window.addEventListener('keydown', (e) => {
            gameState.keysPressed[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (e) => {
            gameState.keysPressed[e.key.toLowerCase()] = false;
        });

        // --- 遊戲主迴圈 (每秒執行約 60 次) ---
        function gameLoop() {
            if (!gameState.isPlaying) return;

            updateSolderPosition();
            checkInteractions();
            updateVisuals();

            requestAnimationFrame(gameLoop);
        }

        // 更新烙鐵視覺位置
        function updateIronVisual() {
            // 偏移量，讓筆尖對準游標位置
            iron.style.left = (gameState.ironPos.x - 10) + 'px'; 
            iron.style.top = (gameState.ironPos.y - 180) + 'px';
        }

        // 更新焊錫位置 (基於鍵盤輸入)
        function updateSolderPosition() {
            const speed = config.solderMoveSpeed;
            if (gameState.keysPressed['w'] || gameState.keysPressed['arrowup']) gameState.solderPos.y -= speed;
            if (gameState.keysPressed['s'] || gameState.keysPressed['arrowdown']) gameState.solderPos.y += speed;
            if (gameState.keysPressed['a'] || gameState.keysPressed['arrowleft']) gameState.solderPos.x -= speed;
            if (gameState.keysPressed['d'] || gameState.keysPressed['arrowright']) gameState.solderPos.x += speed;

            // 限制移動範圍在容器內
            gameState.solderPos.x = Math.max(0, Math.min(containerRect.width, gameState.solderPos.x));
            gameState.solderPos.y = Math.max(0, Math.min(containerRect.height, gameState.solderPos.y));

            solderWire.style.left = gameState.solderPos.x + 'px';
            solderWire.style.top = gameState.solderPos.y + 'px';
        }

        // 核心互動邏輯檢查
        function checkInteractions() {
            // 1. 獲取各個尖端的實際位置 (相對於視窗)
            const ironTipRect = ironTip.getBoundingClientRect();
            const solderTipRect = solderTip.getBoundingClientRect();

            // 2. 計算與焊盤中心的距離
            const distIronToPad = Math.hypot(
                ironTipRect.left - (padRect.left + padRadius),
                ironTipRect.top - (padRect.top + padRadius)
            );
            const distSolderToPad = Math.hypot(
                solderTipRect.left - (padRect.left + padRadius),
                solderTipRect.top - (padRect.top + padRadius)
            );

            // 判定是否接觸焊盤 (距離小於半徑)
            const isIronOnPad = distIronToPad < padRadius;
            const isSolderOnPad = distSolderToPad < padRadius;

            // 3. 加熱邏輯
            // 條件：滑鼠按住 且 烙鐵在焊盤上
            if (gameState.isMouseHeld && isIronOnPad) {
                gameState.temperature = Math.min(config.maxTemp, gameState.temperature + config.heatUpRate);
                iron.classList.add('active');
                pad.classList.add('heating');
            } else {
                gameState.temperature = Math.max(25, gameState.temperature - config.coolDownRate);
                iron.classList.remove('active');
                pad.classList.remove('heating');
            }

            // 4. 融錫邏輯
            // 條件：溫度足夠 且 焊錫接觸焊盤
            if (gameState.temperature > config.meltTempThreshold && isSolderOnPad) {
                // 焊錫變大
                gameState.blobSize += 0.5;
            }

            // 5. 遊戲結束判定
            // 如果焊錫太大 (短路)
            if (gameState.blobSize > 120) {
                endGame("短路啦！", "焊錫加太多變成史萊姆了！失敗！", "#FF0055");
            }
            // 如果溫度過高 (燒焦)
            if (gameState.temperature >= config.maxTemp) {
                endGame("燒焦了！", "烙鐵放太久，基板都碳化了！", "#FF0055");
            }
            
            // 勝利判定：當玩家停止操作，且有焊錫時進行結算
            // 這裡簡化為：如果焊錫達到一定大小且玩家移開烙鐵或焊錫
            if (gameState.blobSize > 20 && (!isIronOnPad || !isSolderOnPad) && !gameState.isMouseHeld && gameState.temperature < 100) {
                 evaluateResult();
            }
        }
        
        function evaluateResult() {
             if (gameState.blobSize >= config.idealBlobSizeMin && gameState.blobSize <= config.idealBlobSizeMax) {
                endGame("完美焊接！", "S級！飽滿圓潤的富士山形，這就是職人的技術！", varCSS('--pop-cyan'));
                 solderBlob.style.background = "radial-gradient(circle at 30% 30%, #fff, #bbb)"; // 變亮
            } else if (gameState.blobSize < config.idealBlobSizeMin) {
                 endGame("空焊風險", "焊錫太少了，可能接觸不良喔。", varCSS('--pop-yellow'));
            } else if (gameState.blobSize > config.idealBlobSizeMax) {
                 endGame("有點肥...", "雖然會通電，但焊點變成球形了，錫加太多了。", varCSS('--pop-yellow'));
            }
        }


        // 更新介面顯示
        function updateVisuals() {
            // 溫度條
            const tempPercent = Math.min(100, (gameState.temperature / config.maxTemp) * 100);
            tempBar.style.width = tempPercent + "%";
            tempText.innerText = Math.floor(gameState.temperature);

            // 焊錫球大小
            solderBlob.style.width = gameState.blobSize + 'px';
            solderBlob.style.height = gameState.blobSize + 'px';
        }

        // 結束遊戲顯示結果
        function endGame(title, desc, color) {
            if(!gameState.isPlaying) return; // 避免重複觸發
            gameState.isPlaying = false;
            iron.classList.remove('active');
            pad.classList.remove('heating');
            
            document.getElementById('result-title').innerText = title;
            document.getElementById('result-title').style.color = color;
            document.getElementById('result-desc').innerText = desc;
            resultOverlay.style.display = "flex";
        }

        // 重置遊戲
        function resetGame() {
            gameState = {
                isPlaying: true,
                isMouseHeld: false,
                ironPos: { x: 0, y: 0 },
                solderPos: { x: 600, y: 400 },
                temperature: 25,
                blobSize: 0,
                keysPressed: {}
            };
            solderBlob.style.background = "linear-gradient(135deg, #fff 0%, #aaa 100%)";
            resultOverlay.style.display = "none";
            // 重新抓取位置資訊避免跑版
            containerRect = container.getBoundingClientRect();
            padRect = pad.getBoundingClientRect();
            gameLoop();
        }

        // 輔助函數：讀取 CSS 變數
        function varCSS(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        // --- 啟動遊戲 ---
        // 確保圖片載入後再開始計算位置 (雖然這裡沒用圖片，但這是一個好習慣)
        window.onload = () => {
             resetGame();
        };
        // 視窗大小改變時重新計算座標
        window.onresize = () => {
            containerRect = container.getBoundingClientRect();
            padRect = pad.getBoundingClientRect();
        }

    </script>
</body>
</html>